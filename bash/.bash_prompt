#!/usr/bin/env bash

# Format	     Foreground  Background 
# 0: normal      30: Black   40: Black
# 1: bold        31: Red     41: Red
# 4: Underlined  32: Green   42: Green
#                33: Yellow  43: Yellow
#                34: Blue    44: Blue
#                35: Purple  45: Purple
#                36: Cyan    46: Cyan
#                37: White   47: White

      NC='\e[0m'
#  BLACK='\e[0;30m'
#    RED='\e[0;31m'
#  GREEN='\e[0;32m'
# YELLOW='\e[0;33m'
#   BLUE='\e[0;34m'
# PURPLE='\e[0;35m'
#   CYAN='\e[0;36m'
#  WHITE='\e[0;37m'
   RED_W='\e[1;41;37m'
 GREEN_W='\e[1;42;37m'
YELLOW_W='\e[1;43;37m'
  BLUE_W='\e[1;44;37m'
  BLUE_B='\e[1;40;34m'

##################################################################################################
# Default Bash Prompt of Ubuntu
##################################################################################################
#__# set a fancy prompt (non-color, unless we know we "want" color)
#__case "$TERM" in
#__    xterm-color|*-256color) color_prompt=yes;;
#__esac
#__
#__# uncomment for a colored prompt, if the terminal has the capability; turned
#__# off by default to not distract the user: the focus in a terminal window
#__# should be on the output of commands, not on the prompt
#__#force_color_prompt=yes
#__
#__if [ -n "$force_color_prompt" ]; then
#__    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
#__	# We have color support; assume it's compliant with Ecma-48
#__	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
#__	# a case would tend to support setf rather than setaf.)
#__	color_prompt=yes
#__    else
#__	color_prompt=
#__    fi
#__fi
#__
#__if [ "$color_prompt" = yes ]; then
#__    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
#__else
#__    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
#__fi
#__
#__unset color_prompt force_color_prompt
#__
#__# If this is an xterm set the title to user@host:dir
#__case "$TERM" in
#__xterm*|rxvt*)
#__    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
#__    ;;
#__*)
#__    ;;
#__esac

##################################################################################################
# Powerline Marks
##################################################################################################
#__NUM_JOBS=$(jobs -rp | wc -l)
#__GIT_BRANCH=$(__git_ps1)
#__
#__GREY="\[\e[48;5;240m\]\[\e[38;5;250m\]"
#__GREY_END="\[\e[48;5;2m\]\[\e[38;5;240m\]"
#__
#__GREEN="\[\e[48;5;2m\]\[\e[38;5;255m\]"
#__GREEN_END="\[\e[48;5;236m\]\[\e[38;5;2m\]"
#__
#__ORANGE="\[\e[48;5;208m\]\[\e[38;5;255m\]"
#__ORANGE_END="\[\e[48;5;236m\]\[\e[38;5;208m\]"
#__ORANGE_RET_END="\[\e[48;5;160m\]\[\e[38;5;208m\]" # when next segment is prompt with return code
#__
#__BLUE="\[\e[48;5;27m\]\[\e[38;5;255m\]"
#__BLUE_END="\[\e[48;5;208m\]\[\e[38;5;27m\]"           # when next segment is git
#__BLUE_END_JOBS="\[\e[48;5;93m\]\[\e[38;5;27m\]"       # when next segment is jobs
#__BLUE_END_ALT="\[\e[48;5;236m\]\[\e[38;5;27m\]"       # when next segment is prompt
#__BLUE_END_RET="\[\e[48;5;160m\]\[\e[38;5;27m\]"       # when next segment is prompt with return code
#__
#__JOBS="\[\e[48;5;93m\]\[\e[38;5;255m\] ⏎"
#__JOBS_END="\[\e[48;5;236m\]\[\e[38;5;93m\]"           # when next segment is prompt
#__JOBS_NO_RET_END="\[\e[48;5;208m\]\[\e[38;5;93m\]"    # when next segment is git
#__JOBS_NO_GIT_END="\[\e[48;5;160m\]\[\e[38;5;93m\]"    # when next segment is prompt with return code
#__
#__RET="\[\e[48;5;160m\]\[\e[38;5;255m\]"
#__RET_END="\[\e[0m\]\[\e[38;5;160m\]\[\e[0m\] "
#__
#__PROMPT="\[\e[48;5;236m\]\[\e[38;5;255m\]"
#__PROMPT_END="\[\e[0m\]\[\e[38;5;236m\]\[\e[0m\] "
#__
#__if [ ! -w "$PWD" ]; then
#__    # Current directory is not writable
#__    BLUE_END="\[\e[48;5;160m\]\[\e[38;5;27m\]\[\e[38;5;255m\]  \[\e[48;5;208m\]\[\e[38;5;160m\]"
#__    BLUE_END_JOBS="\[\e[48;5;160m\]\[\e[38;5;27m\]\[\e[38;5;255m\]  \[\e[48;5;93m\]\[\e[38;5;160m\]"
#__    BLUE_END_ALT="\[\e[48;5;160m\]\[\e[38;5;27m\]\[\e[38;5;255m\]  \[\e[48;5;236m\]\[\e[38;5;160m\]"
#__    BLUE_END_RET="\[\e[48;5;160m\]\[\e[38;5;27m\]\[\e[38;5;255m\]  "
#__fi


##################################################################################################
# PS1 Settings
##################################################################################################

#__# on-the-fly color control, but do not work on MAC
#__smiley ()
#__{
#__    ec=$?
#__    if [ $ec -eq 0 ]; then
#__        echo -e '\e[32m:)\e[0m';
#__    else
#__        echo -e '\e[31m:(\e[0m';
#__    fi
#__    return $ec;
#__
#__}
#__
#__exitcode()
#__{
#__    ec=$?
#__    if [ $ec -ne 0 ]; then
#__        echo -e " $ec ";
#__    fi
#__    return $ec;
#__}
#__
#__smiley_ok ()
#__{
#__    ec=$?
#__    if [ $ec -eq 0 ]; then
#__        echo -e ':) ';
#__    fi
#__    return $ec;
#__}
#__
#__smiley_no ()
#__{
#__    ec=$?
#__    if [ $ec -ne 0 ]; then
#__        echo -e ":( ";
#__    fi
#__    return $ec;
#__}

function _prompt_smiley
{
    ec=$?

    _RED="\e[48;5;160m\e[38;5;255m"
    RED_="\e[48;5;208m\e[38;5;160m"
    _GREEN="\e[48;5;2m\e[38;5;255m"
    GREEN_="\e[48;5;240m\e[38;5;2m"
    _ORANGE="\e[48;5;208m\e[38;5;255m"
    ORANGE_="\e[48;5;240m\e[38;5;208m"

    if [ $ec -eq 0 ]; then
        echo -e "${_GREEN}:)${GREEN_}"
    else
        echo -e "${_RED}:(${RED_}${_ORANGE} ${ec} ${ORANGE_}"
    fi
    return $ec;
}

function _prompt_time
{
    if [[ $EUID -eq 0 ]]; then
        _GREY="\[\e[48;5;240m\e[38;5;250m\]"
        GREY_="\[\e[48;5;160m]\e[38;5;240m\]"
    else
        _GREY="\[\e[48;5;240m\e[38;5;250m\]"
        GREY_="\[\e[48;5;2m\e[38;5;240m\]"
    fi

    echo "${_GREY} \t${GREY_}"
}

function _prompt_user
{
    if [[ $EUID -eq 0 ]]; then
        _COLOR="\[\e[48;5;160m\e[38;5;255m\]"  #red
        COLOR_="\[\e[48;5;0m\e[38;5;160m\]"
    else 
        _COLOR="\[\e[48;5;2m\e[38;5;255m\]"    #green
        COLOR_="\[\e[48;5;0m\e[38;5;2m\]"
    fi
    echo "${_COLOR} \u@\h${COLOR_}"
}

function _prompt_cwd
{
    echo "\[${BLUE_B}\] \w\[${NC}\]"
}

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

if [ "$color_prompt" != "yes" ]; then
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
else
    PS1="${debian_chroot:+($debian_chroot)}\`_prompt_smiley\`$(_prompt_time)$(_prompt_user)$(_prompt_cwd)\n\$ "
fi

unset color_prompt
unset -f _prompt_time
unset -f _prompt_user
unset -f _prompt_cwd


##################################################################################################
# For xtrace debug
##################################################################################################

export PS4=$'+\e[33m $BASH_SOURCE:${BASH_LINENO[0]} ${FUNCNAME[0]:-NOFUNC}() \e[0m+  '

##################################################################################################
# Git Pormpt
##################################################################################################

if [ -z "$GIT_PROMPT_OFF" ] && [ -f ~/.bash-git-prompt/gitprompt.sh ]; then
    GIT_PROMPT_ONLY_IN_REPO=1
    #GIT_PROMPT_START=$(echo "$PS1" | sed 's/\\$ //' | sed 's/\\n$//')
    GIT_PROMPT_START=$(echo "$PS1" | sed 's/\\n$ //' | sed 's/\\n$//')
    source ~/.bash-git-prompt/gitprompt.sh
fi

##################################################################################################
# cd
##################################################################################################

function _cd_mac {
    builtin cd "$@" && COLUMNS="$(tput cols)" CLICOLOR_FORCE=1 ls -CG | awk '{if(NR > 5){print "...(more)"; exit} else print $0}'
}

function _cd_linux {
    builtin cd "$@" && ls -C -w "$(tput cols)" --color=always         | awk '{if(NR > 5){print "...(more)"; exit} else print $0}'
}

if uname -a | grep -q Darwin; then
    alias cd='_cd_mac'
    unset -f _cd_linux
else
    alias cd='_cd_linux'
    unset -f _cd_mac
fi
